# -*- coding: utf-8 -*-
"""CSCN8000_Final_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S2v88V19DdFIBcBpz6ifUksi5sgk9Ogi

# Age and Gender Prediction

Group 2:
- Miracle Messiri (9030337)
- Jagroop Sandhu

**Dataset**

- Source: https://www.kaggle.com/datasets/jangedoo/utkface-new

The UTKFace dataset is a large-scale face dataset consisting of over 20,000 images. The images cover a wide range of ages and races, including males and females. Each image is a 200x200-pixel JPG file.

Using this dataset, we will attempt to create a model capable of predicting the age and gender of an individual. We will use part one of the cropped variations of the images, of which there are almost 10,000. We will be using 5000 images from the `crop_part1` folder.

### Imports
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import os
from PIL import Image, ImageOps
from sklearn.model_selection import train_test_split

from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D, Activation, Dropout, Flatten, Dense
from keras import optimizers

"""### Loading Data"""

import zipfile
import os


# Path to the uploaded ZIP file
zip_path = "/content/crop_part1.zip"

# Destination directory
output_dir = "/content/crop_part1"

# Create output directory if it doesn't exist
os.makedirs(output_dir, exist_ok=True)

# Unzip the file
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(output_dir)

print(f"Files extracted to {output_dir}")

# Path to your dataset folder
dataset_path = '/content/crop_part1/crop_part1/'

# List all image files in the directory
image_files = [os.path.join(dataset_path, f) for f in os.listdir(dataset_path) if f.lower().endswith(('png', 'jpg', 'jpeg'))]

# Process each image
for image_file in image_files:
    try:
        # Open the image
        img = Image.open(image_file)

        img_array = np.array(img)  # Convert to numpy array if needed

        # Display or process the image
        print(f"Processed: {image_file} with shape {img_array.shape}")

    except Exception as e:
        print(f"Error processing {image_file}: {e}")

import tensorflow as tf

images = []
ages = []
genders = []


for i in os.listdir("/content/crop_part1/crop_part1/")[0:5000]:
  split = i.split('_')
  ages.append(int(split[0]))
  genders.append(int(split[1]))
  images.append(Image.open("/content/crop_part1/crop_part1/" + i))

images = pd.Series(list(images), name = 'Images')
ages = pd.Series(list(ages), name = 'Ages')
genders = pd.Series(list(genders), name = 'Genders')

df = pd.concat([images, ages, genders], axis=1)
print(df.head())
print(df.shape)

display(df['Images'][3])
print(df['Ages'][3], df['Genders'][3])

display(df['Images'][2])
print(df['Ages'][2], df['Genders'][2])

display(df['Images'][19])
print(df['Ages'][19], df['Genders'][19])

display(df['Images'][31])
print(df['Ages'][31], df['Genders'][31])

"""0 corresponds to male, 1 corresponds to female.

### Visualising and prepaing Data
"""

#check for missing values
df.isnull().sum()

# Create the density plot
sns.set_theme(style="whitegrid")
sns.histplot(df['Ages'], kde=True, bins=30)

# Convert density to percentage on the y-axis
def to_percentage(y, pos):
    return f'{y * 0.1:.0f}%'

from matplotlib.ticker import FuncFormatter
plt.gca().yaxis.set_major_formatter(FuncFormatter(to_percentage))

# Add labels and title
plt.title("Age Distribution with Density in Percentage", fontsize=16, fontweight='bold')
plt.xlabel("Ages", fontsize=12)
plt.ylabel("Density (%)", fontsize=12)

# Show the plot
plt.show()

"""There are too many faces of people between 0 and 4 years old. The model would fit too well to these ages and not enough to the other ages. We will only include a third of the images between these ages to resolve this."""

under4s = []

for i in range(len(df)):
  if df['Ages'].iloc[i] <= 4:
    under4s.append(df.iloc[i])
under4s = pd.DataFrame(under4s)
under4s = under4s.sample(frac=0.3)

df = df[df['Ages'] > 4]

df = pd.concat([df, under4s], ignore_index = True)

# Create the density plot
sns.set_theme(style="whitegrid")
sns.histplot(df['Ages'], kde=True, bins=30)

# Convert density to percentage on the y-axis
def to_percentage(y, pos):
    return f'{y * 0.1:.0f}%'

from matplotlib.ticker import FuncFormatter
plt.gca().yaxis.set_major_formatter(FuncFormatter(to_percentage))

# Add labels and title
plt.title("Age Distribution with Density in Percentage", fontsize=16, fontweight='bold')
plt.xlabel("Ages", fontsize=12)
plt.ylabel("Density (%)", fontsize=12)

# Show the plot
plt.show()

"""This looks so much better! The dataframe now more accurately represents the population. However, there aren't many photos of persons over 80, so the model wouldn't train effectively on such ages. It is ideal to just exclude the over-80s and develop a model that can forecast the ages of persons under 80."""

df = df[df['Ages'] < 80]

# Create the density plot
sns.set_theme(style="whitegrid")
sns.histplot(df['Ages'], kde=True, bins=20)

# Convert density to percentage on the y-axis
def to_percentage(y, pos):
    return f'{y * 0.1:.0f}%'

from matplotlib.ticker import FuncFormatter
plt.gca().yaxis.set_major_formatter(FuncFormatter(to_percentage))

# Add labels and title
plt.title("Age Distribution with Density in Percentage", fontsize=16, fontweight='bold')
plt.xlabel("Ages", fontsize=12)
plt.ylabel("Density (%)", fontsize=12)

# Show the plot
plt.show()

# Replace 0 and 1 with 'Male' and 'Female'
df['Genders'] = df['Genders'].replace({0: 'Male', 1: 'Female'})

# Create the count plot
sns.set_theme(style="whitegrid")
sns.countplot(x='Genders', data=df)

# Add a title to the graph
plt.title("Gender Distribution in the Dataset", fontsize=16, fontweight='bold')

# Add labels for the axes
plt.xlabel("Gender", fontsize=12)
plt.ylabel("Count", fontsize=12)

"""Here we can see some imbalance in the gender class. To deal with this imbalance we are going to oversample the minority class

"""

print("Class distribution before balancing:")
print(df['Genders'].value_counts())

import pandas as pd
from sklearn.utils import resample


# Separate majority and minority classes
df_majority = df[df['Genders'] == 'Female']
df_minority = df[df['Genders'] == 'Male']

if not df_minority.empty:  # Check if the minority class has samples
    # Oversample the minority class
    df_minority_oversampled = resample(
        df_minority,
        replace=True,  # Sample with replacement
        n_samples=len(df_majority),  # Match majority size
        random_state=42
    )

    # Combine oversampled minority class with the majority class
    df_balanced = pd.concat([df_majority, df_minority_oversampled])
    print("Class distribution after balancing:")
    print(df_balanced['Genders'].value_counts())
else:
    print("Minority class is empty. Cannot perform oversampling.")

import matplotlib.pyplot as plt

# Replace 0 and 1 with 'Male' and 'Female'
df_balanced['Genders'] = df_balanced['Genders'].replace({0: 'Male', 1: 'Female'})

# Create the count plot
sns.set_theme(style="whitegrid")
sns.countplot(x='Genders', data=df_balanced)

# Add a title to the graph
plt.title("Gender Distribution in the Dataset", fontsize=16, fontweight='bold')

# Add labels for the axes
plt.xlabel("Gender", fontsize=12)
plt.ylabel("Count", fontsize=12)

df_balanced = df

x = []
y = []

# Replace ''Male and 'Female' with 0 and 1
df['Genders'] = df['Genders'].replace({'Male': 0, 'Female': 1})

#create a new column for resized images
df['Resized_Images'] = None

for i in range(len(df)):
  # Resize the image and store it in the new column
  resized_image = df['Images'].iloc[i].resize((200, 200), Image.LANCZOS)
  df.at[i, 'Resized_Images'] = resized_image # Use df.at for safer assignment

  # Convert the resized image to a Numpy array and append to the list
  ar = np.asarray(resized_image)
  x.append(ar)

  # Extract labels for age and gender
  agegen = [int(df['Ages'].iloc[i]), int(df['Genders'].iloc[i])]
  y.append(agegen)

# Convert the list of images to a Numpy array
x = np.array(x)

"""### Train Test Split"""

y_age = df['Ages']
y_gender = df['Genders']

# Fix the mismatch
min_length = min(len(x), len(y_age), len(y_gender))
x, y_age, y_gender = x[:min_length], y_age[:min_length], y_gender[:min_length]

x_train_age, x_test_age, y_train_age, y_test_age = train_test_split(x, y_age, test_size=0.2, random_state=42, stratify=y_age)
x_train_gender, x_test_gender, y_train_gender, y_test_gender = train_test_split(x, y_gender, test_size=0.2, random_state=42, stratify=y_gender)

"""### Creating the Models

I'll develop two separate models: one to predict age and one to predict gender. The age model should be able to return continuous numbers that I can round to the nearest integer, whereas the gender model should produce a binary answer.
"""

agemodel = Sequential()
agemodel.add(Conv2D(32, (3, 3), activation='relu', input_shape=(200, 200, 3)))
agemodel.add(MaxPooling2D((2,2)))
agemodel.add(Conv2D(64, (3, 3), activation='relu'))
agemodel.add(MaxPooling2D((2,2)))
agemodel.add(Conv2D(128, (3,3), activation='relu'))
agemodel.add(MaxPooling2D((2,2)))
agemodel.add(Flatten())
agemodel.add(Dense(64, activation='relu'))
agemodel.add(Dropout(0.5))
agemodel.add(Dense(1, activation='relu'))

agemodel.compile(loss='mean_squared_error',
                 optimizer = optimizers.Adam(learning_rate=0.0001))

genmodel = Sequential()
genmodel.add(Conv2D(32, (3, 3), activation='relu', input_shape=(200, 200, 3)))
genmodel.add(MaxPooling2D((2,2)))
genmodel.add(Conv2D(64, (3, 3), activation='relu'))
genmodel.add(MaxPooling2D((2,2)))
genmodel.add(Conv2D(128, (3,3), activation='relu'))
genmodel.add(MaxPooling2D((2,2)))
genmodel.add(Flatten())
genmodel.add(Dense(64, activation='relu'))
genmodel.add(Dropout(0.5))
genmodel.add(Dense(1, activation='sigmoid'))

genmodel.compile(loss='binary_crossentropy',
                 optimizer = optimizers.Adam(learning_rate=0.0001),
                 metrics=['accuracy'])

"""### Training the Models"""

#data augmentation
from tensorflow import keras
from tensorflow.keras.preprocessing.image import ImageDataGenerator

datagen = ImageDataGenerator(
    rescale=1./255., width_shift_range = 0.1, height_shift_range = 0.1, horizontal_flip = True)

test_datagen = ImageDataGenerator(rescale=1./255)

train1 = datagen.flow(x_train_age, y_train_age, batch_size=32)
test1 = test_datagen.flow(x_test_age, y_test_age, batch_size=32)

callbacks1 = [
    keras.callbacks.ModelCheckpoint(
        filepath="./models/convnet_from_scratch_with_augmentation1.keras",
        save_best_only=True,
        monitor="val_loss")
]

history1 = agemodel.fit(train1, epochs=30, shuffle=True, validation_data=test1, callbacks=callbacks1)

"""#### Plotting results"""

import matplotlib.pyplot as plt

loss = history1.history["loss"]
val_loss = history1.history["val_loss"]
epochs = range(1, len(loss) + 1)
plt.plot(epochs, loss, "bo", label="Training loss")
plt.plot(epochs, val_loss, "b", label="Validation loss")
plt.title("Training and validation loss")
plt.legend()
plt.show()

#data augmentation
from tensorflow import keras
from tensorflow.keras.preprocessing.image import ImageDataGenerator

datagen = ImageDataGenerator(
    rescale=1./255., width_shift_range = 0.1, height_shift_range = 0.1, horizontal_flip = True)

test_datagen = ImageDataGenerator(rescale=1./255)

train2 = datagen.flow(x_train_gender, y_train_gender, batch_size=64)
test2 = test_datagen.flow(x_test_gender, y_test_gender, batch_size=64)

callbacks2 = [
    keras.callbacks.ModelCheckpoint(
        filepath="./models/convnet_from_scratch_with_augmentation2.keras",
        save_best_only=True,
        monitor="val_loss")
]

history2 = genmodel.fit(train2, epochs=30, shuffle=True, validation_data=test2, callbacks=callbacks2)

"""#### Plotting results"""

import matplotlib.pyplot as plt

acc = history2.history["accuracy"]
val_acc = history2.history["val_accuracy"]
loss = history2.history["loss"]
val_loss = history2.history["val_loss"]
epochs = range(1, len(acc) + 1)
plt.plot(epochs, acc, "bo", label="Training accuracy")
plt.plot(epochs, val_acc, "b", label="Validation accuracy")
plt.title("Training and validation accuracy")
plt.legend()
plt.figure()
plt.plot(epochs, loss, "bo", label="Training loss")
plt.plot(epochs, val_loss, "b", label="Validation loss")
plt.title("Training and validation loss")
plt.legend()
plt.show()

"""#### Evaluating the models"""

# Path to the uploaded ZIP file
test_zip_path = "/content/test_data.zip"

# Destination directory
test_output_dir = "/content/test_data"

# Create output directory if it doesn't exist
os.makedirs(test_output_dir, exist_ok=True)

# Unzip the file
with zipfile.ZipFile(test_zip_path, 'r') as zip_ref:
    zip_ref.extractall(test_output_dir)

print(f"Files extracted to {test_output_dir}")

def process_and_predict(file):
    im = Image.open(file)
    width, height = im.size
    if width == height:
        im = im.resize((200,200), Image.LANCZOS)
    else:
        if width > height:
            left = width/2 - height/2
            right = width/2 + height/2
            top = 0
            bottom = height
            im = im.crop((left,top,right,bottom))
            im = im.resize((200,200), Image.LANCZOS)
        else:
            left = 0
            right = width
            top = 0
            bottom = width
            im = im.crop((left,top,right,bottom))
            im = im.resize((200,200), Image.LANCZOS)

    ar = np.asarray(im)
    ar = ar.astype('float32')
    ar /= 255.0
    ar = ar.reshape(-1, 200, 200, 3)

    age = agemodel.predict(ar)
    gender = np.round(genmodel.predict(ar))
    if gender == 0:
        gender = 'male'
    elif gender == 1:
        gender = 'female'

    print('Age:', int(age), '\n Gender:', gender)
    return im.resize((300,300), Image.LANCZOS)

process_and_predict('/content/test_data/test_data/50_0_1_20170117173418899.jpg.chip.jpg')

process_and_predict('/content/test_data/test_data/100_1_0_20170119212053665.jpg.chip.jpg')

"""#### Evaluating the Age model"""

import os
import numpy as np
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing.image import load_img, img_to_array

# Load the model
test_age_model = load_model("./models/convnet_from_scratch_with_augmentation1.keras")

# Path to image folder
image_folder = "/content/test_data/test_data/"

# Preprocessing function
def preprocess_image(image_path, target_size):
    """Loads and preprocesses an image."""
    img = load_img(image_path, target_size=target_size)  # Resize image
    img_array = img_to_array(img)  # Convert to numpy array
    img_array = img_array / 255.0  # Normalize to [0, 1]
    return np.expand_dims(img_array, axis=0)  # Add batch dimension

# Iterate over images in the folder
target_size = (200, 200)  # Replace with the input size of your model
image_files = [os.path.join(image_folder, f) for f in os.listdir(image_folder) if f.endswith(('.jpg', '.png', 'jpeg'))]

predictions = []
for image_path in image_files:
    # Preprocess the image
    img_preprocessed = preprocess_image(image_path, target_size)

    # Make prediction
    pred = test_age_model.predict(img_preprocessed)
    predictions.append((image_path, pred))

# Print results
for image_path, pred in predictions:
    print(f"Image: {image_path}, Prediction: {pred}")

import os
import numpy as np
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing.image import load_img, img_to_array
from sklearn.metrics import mean_squared_error, mean_absolute_error

# Load the model
test_age_model = load_model("./models/convnet_from_scratch_with_augmentation1.keras")

# Path to image folder
image_folder = "/content/test_data/test_data/"

# Preprocessing function
def preprocess_image(image_path, target_size):
    """Loads and preprocesses an image."""
    img = load_img(image_path, target_size=target_size)  # Resize image
    img_array = img_to_array(img)  # Convert to numpy array
    img_array = img_array / 255.0  # Normalize to [0, 1]
    return np.expand_dims(img_array, axis=0)  # Add batch dimension

# Iterate over images in the folder
target_size = (200, 200)  # Replace with the input size of your model
image_files = [os.path.join(image_folder, f) for f in os.listdir(image_folder) if f.endswith(('.jpg', '.png', 'jpeg'))]

true_values = []
predicted_values = []

for image_path in image_files:
    # Get the base name (e.g., "50_image1.jpg")
    image_name = os.path.basename(image_path)

    # Extract ground truth from the file name
    try:
        ground_truth_value = int(image_name.split('_')[0])  # Split by '_' and get the first part
        true_values.append(ground_truth_value)  # Append ground truth

        # Preprocess the image
        img_preprocessed = preprocess_image(image_path, target_size)

        # Make prediction
        pred = test_age_model.predict(img_preprocessed)
        predicted_values.append(pred[0][0])  # Assuming regression output is a single value
    except ValueError:
        print(f"Skipping file {image_name} as it doesn't contain a valid ground truth value.")

# Calculate metrics
mse = mean_squared_error(true_values, predicted_values)
mae = mean_absolute_error(true_values, predicted_values)
rmse = np.sqrt(mse)

# Print results
print(f"Mean Squared Error (MSE): {mse:.2f}")
print(f"Mean Absolute Error (MAE): {mae:.2f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")

"""#### Evaluating the gender model"""

import os
import numpy as np
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing.image import load_img, img_to_array

# Load the model
test_gender_model = load_model("./models/convnet_from_scratch_with_augmentation2.keras")

# Path to image folder
image_folder = "/content/test_data/test_data/"

# Preprocessing function
def preprocess_image(image_path, target_size):
    """Loads and preprocesses an image."""
    img = load_img(image_path, target_size=target_size)  # Resize image
    img_array = img_to_array(img)  # Convert to numpy array
    img_array = img_array / 255.0  # Normalize to [0, 1]
    return np.expand_dims(img_array, axis=0)  # Add batch dimension

# Iterate over images in the folder
target_size = (200, 200)  # Replace with the input size of your model
image_files = [os.path.join(image_folder, f) for f in os.listdir(image_folder) if f.endswith(('.jpg', '.png', 'jpeg'))]

predictions = []
for image_path in image_files:
    # Preprocess the image
    img_preprocessed = preprocess_image(image_path, target_size)

    # Make prediction
    pred = test_gender_model.predict(img_preprocessed)
    predictions.append((image_path, pred))

# Print results
for image_path, pred in predictions:
    print(f"Image: {image_path}, Prediction: {pred}")

from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score

# Define a margin of error for correct classification
margin_of_error = 5  # Example: Prediction is correct if within ±5 of the true value

# Convert regression outputs to binary classification (correct/incorrect)
classification_true = []
classification_pred = []

for true, pred in zip(true_values, predicted_values):
    is_correct = abs(true - pred) <= margin_of_error  # Correct if within margin
    classification_true.append(1)  # 1 = true label is "correct"
    classification_pred.append(1 if is_correct else 0)  # 1 = "predicted correct"

# Calculate classification metrics
accuracy = accuracy_score(classification_true, classification_pred)
precision = precision_score(classification_true, classification_pred)
recall = recall_score(classification_true, classification_pred)
f1 = f1_score(classification_true, classification_pred)

# Print metrics
print(f"Accuracy: {accuracy:.2f}")
print(f"Precision: {precision:.2f}")
print(f"Recall: {recall:.2f}")
print(f"F1 Score: {f1:.2f}")

import numpy as np
from sklearn.metrics import accuracy_score, mean_absolute_error, confusion_matrix, classification_report

# Test data
true_genders = y_train_gender.values.astype(int)  # Ensure binary labels are integers
true_ages = y_train_age.values

# Gender naive model: Predict majority class
naive_gender_pred = [np.bincount(true_genders).argmax()] * len(true_genders)

# Age naive model: Predict mean age
mean_age = np.mean(true_ages)
naive_age_pred = [mean_age] * len(true_ages)

# Evaluate Naive Models
gender_accuracy = accuracy_score(true_genders, naive_gender_pred)
age_mae = mean_absolute_error(true_ages, naive_age_pred)

# Confusion Matrix for Gender Prediction
conf_matrix = confusion_matrix(true_genders, naive_gender_pred)

# Classification Report for Gender Prediction
class_report = classification_report(true_genders, naive_gender_pred, target_names=["Female", "Male"])

print("Naive Gender Accuracy:", gender_accuracy)
print("Naive Age MAE:", age_mae)
#print("Confusion Matrix for Gender Prediction:\n", conf_matrix)
print("Classification Report for Gender Prediction:\n", class_report)